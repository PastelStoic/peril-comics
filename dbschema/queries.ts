// GENERATED by @edgedb/generate v0.0.7
// Run 'npx @edgedb/generate queries --file' to re-generate

import type {Executor} from "edgedb";

export async function createComic(client: Executor, args: {
  "title": string;
  "description": string;
}): Promise<{
  "id": string;
}> {
  return client.queryRequiredSingle(`insert Comic {
  title := <str>$title,
  description := <str>$description,
}`, args);
}

export async function addImageToComic(client: Executor, args: {
  "cloudflare_id": string;
  "image_name": string;
  "page": number;
  "comicId": string;
}): Promise<{
  "id": string;
}> {
  return client.queryRequiredSingle(`with usedImage := (select (
  insert CloudflareImage {
    image_id := <str>$cloudflare_id,
    image_name := <str>$image_name,
  } unless conflict on .image_name else (
    update CloudflareImage set {
      image_id := <str>$cloudflare_id,
    })
  ))
insert ComicImage {
  name := <str>$image_name,
  image := usedImage,
  startPage := <int32>$page,
  endPage := <int32>$page,
  layer := 1,
  comic := (select Comic filter .id = <uuid>$comicId),
}`, args);
}

export async function addTagToImage(client: Executor, args: {
  "imageId": string;
  "tagName": string;
}): Promise<{
  "id": string;
} | null> {
  return client.querySingle(`update ComicImage filter .id = <uuid>$imageId
set {
  tags += (select Tag filter .ref_name = <str>$tagName)
}`, args);
}

export async function changeImageLayer(client: Executor, args: {
  "imageId": string;
  "layer": number;
}): Promise<{
  "id": string;
} | null> {
  return client.querySingle(`update ComicImage filter .id = <uuid>$imageId
set {
  layer := <int32>$layer,
}`, args);
}

export async function changeImagePages(client: Executor, args: {
  "imageId": string;
  "startPage": number;
  "endPage": number;
}): Promise<{
  "id": string;
} | null> {
  return client.querySingle(`update ComicImage filter .id = <uuid>$imageId
set {
  startPage := <int32>$startPage,
  endPage := <int32>$endPage,
}`, args);
}

export async function updateComic(client: Executor, args: {
  "id": string;
  "title": string;
  "description": string;
  "private": boolean;
}): Promise<{
  "id": string;
} | null> {
  return client.querySingle(`update Comic filter .id = <uuid>$id
set {
  title := <str>$title,
  description := <str>$description,
  is_private := <bool>$private,
}`, args);
}

export async function getAllComics(client: Executor, args: {
  "includeHidden": boolean;
}): Promise<{
  "id": string;
  "title": string;
  "description": string;
  "thumbnail": {
    "image_id": string;
  } | null;
  "pages": number;
  "tags": {
    "display_name": string;
    "is_hidden": boolean;
  }[];
}[]> {
  return client.query(`select Comic {
  id,
  title,
  description,
  thumbnail: {
    image_id,
  },
  pages,
  tags: {
    display_name,
    is_hidden,
  },
} filter (<bool>$includeHidden or not .is_private)`, args);
}

export async function searchComics(client: Executor, args: {
  "searchText": string;
  "includeHidden": boolean;
  "page"?: number | null;
}): Promise<{
  "id": string;
  "title": string;
  "description": string;
  "thumbnail": {
    "image_id": string;
  } | null;
  "pages": number;
  "tags": {
    "display_name": string;
    "is_hidden": boolean;
  }[];
}[]> {
  return client.query(`select Comic {
  id,
  title,
  description,
  thumbnail: {
    image_id,
  },
  pages,
  tags: {
    display_name,
    is_hidden,
  },
} filter .title ilike <str>$searchText and (<bool>$includeHidden or not .is_private)
offset (5 * <optional int32>$page ?? 0)
limit 5`, args);
}

export async function deleteComicImage(client: Executor, args: {
  "id": string;
}): Promise<{
  "id": string;
} | null> {
  return client.querySingle(`delete ComicImage filter .id = <uuid>$id`, args);
}

export async function searchUnassignedImages(client: Executor, args: {
  "text"?: string | null;
}): Promise<{
  "id": string;
  "image_name": string;
  "image_id": string;
}[]> {
  return client.query(`with searchText := <optional str>$text
select CloudflareImage {
  id,
  image_name,
  image_id,
} filter (not exists .<image[is ComicImage]) and 
(not exists .<thumbnail[is Comic]) and
((.image_name ilike '%' ++ searchText ++ '%') if exists searchText else true)`, args);
}

export async function removeTagFromImage(client: Executor, args: {
  "imageId": string;
  "tagName": string;
}): Promise<{
  "id": string;
} | null> {
  return client.querySingle(`update ComicImage filter .id = <uuid>$imageId
set {
  tags -= (select Tag filter .ref_name = <str>$tagName)
}`, args);
}

export async function updateComicImage(client: Executor, args: {
  "tags": string[];
  "id": string;
  "name": string;
  "startPage": number;
  "endPage": number;
}): Promise<{
  "id": string;
} | null> {
  return client.querySingle(`with newTags := array_unpack(<array<str>>$tags)
update ComicImage filter .id = <uuid>$id
set {
  name := <str>$name,
  startPage := <int32>$startPage,
  endPage := <int32>$endPage,
  layer := 1,
  tags := (select Tag filter .ref_name in newTags)
}`, args);
}

export async function searchTags(client: Executor, args: {
  "name"?: string | null;
}): Promise<{
  "display_name": string;
  "ref_name": string;
}[]> {
  return client.query(`select Tag {
  display_name,
  ref_name,
} filter (((.display_name ilike '%' ++ <optional str>$name ++ '%')) if exists <optional str>$name else true)
limit 5
# order by frequency of use?`, args);
}

export async function createUserAccount(client: Executor, args: {
  "id": string;
  "provider": string;
  "token_type": string;
  "expires_in": number;
  "access_token": string;
  "refresh_token": string;
  "providerAccountId": string;
  "scope": string;
}): Promise<{
  "id": string;
}> {
  return client.queryRequiredSingle(`INSERT Account {
  user := (SELECT User FILTER .id = <uuid>$id),
  type := "oauth",
  provider := <str>$provider,
  token_type := <str>$token_type,
  expires_at := <int64>$expires_in,
  access_token := <str>$access_token,
  refresh_token := <str>$refresh_token,
  providerAccountId := <str>$providerAccountId,
  scope := <str>$scope,
} UNLESS CONFLICT ON .providerAccountId
ELSE (UPDATE Account SET {
  expires_at := <int64>$expires_in,
  access_token := <str>$access_token,
  refresh_token := <str>$refresh_token,
})`, args);
}

export async function getUserAccount(client: Executor, args: {
  "userId": string;
  "provider": string;
}): Promise<{
  "access_token": string | null;
} | null> {
  return client.querySingle(`select Account {
  access_token,
} filter .user.id = <uuid>$userId and .provider ilike <str>$provider
limit 1`, args);
}

export async function setRoleToGuest(client: Executor, args: {
  "id": string;
}): Promise<{
  "id": string;
} | null> {
  return client.querySingle(`update User filter .id = <uuid>$id 
set {
  role := 'guest',
}`, args);
}

export async function getComicByTitle(client: Executor, args: {
  "title": string;
}): Promise<{
  "id": string;
  "title": string;
  "description": string;
  "pages": number;
  "is_private": boolean;
  "tags": {
    "display_name": string;
    "ref_name": string;
    "enabled": boolean;
    "creates_button": boolean;
  }[];
  "images": {
    "id": string;
    "image": {
      "image_id": string;
    };
    "name": string;
    "layer": number;
    "startPage": number;
    "endPage": number;
    "tags": {
      "display_name": string;
      "ref_name": string;
      "inverted": boolean;
    }[];
    "display_versions": string[];
  }[];
  "states": {
    "name": string;
    "tag_states": [string, boolean][];
  }[];
} | null> {
  return client.querySingle(`select Comic {
  id,
  title,
  description,
  pages,
  is_private,
  tags: {
    display_name,
    ref_name,
    enabled := @enabled ?? true,
    creates_button,
  },
  images: {
    id,
    image: {
      image_id,
    },
    name,
    layer,
    startPage,
    endPage,
    tags: {
      display_name,
      ref_name,
      inverted := @inverted ?? false,
    },
    display_versions,
  } order by .layer,
  states: {
    name,
    tag_states,
  },
} filter .title ilike <str>$title limit 1;`, args);
}