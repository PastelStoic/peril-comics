// GENERATED by @edgedb/generate v0.0.7
// Run 'npx @edgedb/generate queries --file' to re-generate

import type {Executor} from "edgedb";

export async function createComic(client: Executor, args: {
  "title": string;
  "description": string;
}): Promise<{
  "id": string;
}> {
  return client.queryRequiredSingle(`insert Comic {
  title := <str>$title,
  description := <str>$description,
}`, args);
}

export async function createCloudflareImage(client: Executor, args: {
  "id": string;
  "name": string;
}): Promise<{
  "id": string;
}> {
  return client.queryRequiredSingle(`insert CloudflareImage {
  image_id := <str>$id,
  image_name := <str>$name,
} 
unless conflict on .image_name 
else (
  update CloudflareImage set {
    image_id := <str>$id,
  }
)`, args);
}

export async function deleteComicImage(client: Executor, args: {
  "id": string;
}): Promise<{
  "id": string;
} | null> {
  return client.querySingle(`delete ComicImage filter .id = <uuid>$id`, args);
}

export async function updateComic(client: Executor, args: {
  "id": string;
  "title": string;
  "description": string;
  "private": boolean;
}): Promise<{
  "id": string;
} | null> {
  return client.querySingle(`update Comic filter .id = <uuid>$id
set {
  title := <str>$title,
  description := <str>$description,
  is_private := <bool>$private,
}`, args);
}

export async function searchUnassignedImages(client: Executor, args: {
  "text"?: string | null;
}): Promise<{
  "id": string;
  "image_name": string;
  "image_id": string;
}[]> {
  return client.query(`with searchText := <optional str>$text
select CloudflareImage {
  id,
  image_name,
  image_id,
} filter (not exists .<image[is ComicImage]) and 
(not exists .<thumbnail[is Comic]) and
((.image_name ilike '%' ++ searchText ++ '%') if exists searchText else true)`, args);
}

export async function setRoleToGuest(client: Executor, args: {
  "id": string;
}): Promise<{
  "id": string;
} | null> {
  return client.querySingle(`update User filter .id = <uuid>$id 
set {
  role := 'guest',
}`, args);
}

export async function getUserAccount(client: Executor, args: {
  "userId": string;
  "provider": string;
}): Promise<{
  "access_token": string | null;
} | null> {
  return client.querySingle(`select Account {
  access_token,
} filter .user.id = <uuid>$userId and .provider ilike <str>$provider
limit 1`, args);
}

export async function searchTags(client: Executor, args: {
  "name"?: string | null;
}): Promise<{
  "display_name": string;
  "ref_name": string;
}[]> {
  return client.query(`select Tag {
  display_name,
  ref_name,
} filter (((.display_name ilike '%' ++ <optional str>$name ++ '%')) if exists <optional str>$name else true)`, args);
}

export async function updateComicImage(client: Executor, args: {
  "tags": string[];
  "id": string;
  "name": string;
  "startPage": number;
  "endPage": number;
}): Promise<{
  "id": string;
} | null> {
  return client.querySingle(`with newTags := array_unpack(<array<str>>$tags)
update ComicImage filter .id = <uuid>$id
set {
  name := <str>$name,
  startPage := <int32>$startPage,
  endPage := <int32>$endPage,
  layer := 1,
  tags := (select Tag filter .ref_name in newTags)
}`, args);
}

export async function addImageToComic(client: Executor, args: {
  "imageId": string;
  "page": number;
  "comicId": string;
}): Promise<{
  "id": string;
}> {
  return client.queryRequiredSingle(`with usedImage := (select CloudflareImage filter .id = <uuid>$imageId)
insert ComicImage {
  name := usedImage.image_name,
  image := usedImage,
  startPage := <int32>$page,
  endPage := <int32>$page,
  layer := 1,
  comic := (select Comic filter .id = <uuid>$comicId),
}`, args);
}

export async function searchComics(client: Executor, args: {
  "searchText": string;
  "includeHidden": boolean;
}): Promise<{
  "id": string;
  "title": string;
  "description": string;
  "thumbnail": {
    "image_id": string;
  } | null;
  "pages": number;
  "tags": {
    "display_name": string;
    "is_hidden": boolean;
  }[];
}[]> {
  return client.query(`select Comic {
  id,
  title,
  description,
  thumbnail: {
    image_id,
  },
  pages,
  tags: {
    display_name,
    is_hidden,
  },
} filter .title ilike <str>$searchText and (<bool>$includeHidden or not .is_private)`, args);
}

export async function getAllComics(client: Executor, args: {
  "includeHidden": boolean;
}): Promise<{
  "id": string;
  "title": string;
  "description": string;
  "thumbnail": {
    "image_id": string;
  } | null;
  "pages": number;
  "tags": {
    "display_name": string;
    "is_hidden": boolean;
  }[];
}[]> {
  return client.query(`select Comic {
  id,
  title,
  description,
  thumbnail: {
    image_id,
  },
  pages,
  tags: {
    display_name,
    is_hidden,
  },
} filter (<bool>$includeHidden or not .is_private)`, args);
}

export async function getComicByTitle(client: Executor, args: {
  "title": string;
}): Promise<{
  "id": string;
  "title": string;
  "description": string;
  "pages": number;
  "is_private": boolean;
  "tags": {
    "display_name": string;
    "ref_name": string;
    "enabled": boolean;
  }[];
  "images": {
    "id": string;
    "image": {
      "image_id": string;
    };
    "name": string;
    "layer": number;
    "startPage": number;
    "endPage": number;
    "tags": {
      "display_name": string;
      "ref_name": string;
      "inverted": boolean;
    }[];
  }[];
} | null> {
  return client.querySingle(`select Comic {
  id,
  title,
  description,
  pages,
  is_private,
  tags: {
    display_name,
    ref_name,
    enabled := @enabled ?? true,
  },
  images: {
    id,
    image: {
      image_id,
    },
    name,
    layer,
    startPage,
    endPage,
    tags: {
      display_name,
      ref_name,
      inverted := @inverted ?? false,
    },
  } order by .layer,

} filter .title ilike <str>$title limit 1;`, args);
}